#pragma once
#include "IPymlFile.h"
#include <boost/optional.hpp>
#include <boost/python/object.hpp>
#include <string>

// A *mutable* way to hod the source from which the response will be generated.
class ResponseSource {
    std::string baseFilename;
    boost::optional<std::string> sourceFilename;
    boost::optional<const IPymlFile&> pymlFile;
    boost::optional<std::string> moduleName;
    boost::optional<boost::python::object> mvcController;

public:
    explicit ResponseSource(std::string baseFilename) : baseFilename(std::move(baseFilename)) {
    }

    // Leave copy constructors/etc autogenerated.

    bool isDynamic() const {
        if (pymlFile) {
            return pymlFile->isDynamic();
        }
        if (mvcController || moduleName) {
            return true;
        }
        return false;
    }

    const std::string& getBaseFilename() const {
        return baseFilename;
    }

    const std::string& getSourceFilename() const {
        return sourceFilename.get();
    }

    const IPymlFile& getPymlFile() const {
        return pymlFile.get();
    }

    const std::string& getModuleName() const {
        return moduleName.get();
    }

    const boost::python::object& getMvcController() const {
        return mvcController.get();
    }

    void setSourceFilename(std::string&& newFilename) {
        sourceFilename = std::move(newFilename);
    }

    void setPymlFile(const IPymlFile& pymlFile) {
        this->pymlFile = pymlFile;
    }

    void setModuleName(std::string&& newName) {
        moduleName = std::move(newName);
    }

    void setMvcController(boost::python::object newMvcController) {
        mvcController = std::move(newMvcController);
    }

    bool hasFilename() const {
        return (bool) sourceFilename;
    }

    bool hasPymlFile() const {
        return (bool) pymlFile;
    }

    bool hasModuleName() const {
        return (bool) moduleName;
    }

    bool hasMvcController() const {
        return (bool) mvcController;
    }
};
